{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/learning_meme/epics/listenEpic.ts","dependencies":[{"path":"/home/just/repos/front/src/learning_meme/epics/listenEpic.ts","mtime":1517225633464},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Observable_1 = require(\"rxjs/Observable\");\nconst constants_1 = require(\"../../constants\");\nconst actions_1 = require(\"../actions\");\nexports.listenEpic = (action$, store) => action$.ofType(constants_1.LEARNING_MEME_LISTEN)\n    .switchMap(action => {\n    return new Observable_1.Observable(observer => {\n        const { listen, inputState, } = store.getState().learningMemeStore;\n        if (action.payload === 'ENTER' && listen) {\n            observer.next(actions_1.check(inputState.trim()));\n        }\n        else if (listen) {\n            observer.next(actions_1.setInput(action.payload));\n        }\n        else {\n            observer.next(actions_1.next());\n        }\n        observer.complete();\n    });\n});\n",{"version":3,"file":"/home/just/repos/front/src/learning_meme/epics/listenEpic.ts","sourceRoot":"","sources":["/home/just/repos/front/src/learning_meme/epics/listenEpic.ts"],"names":[],"mappings":";;AACA,gDAA4C;AAC5C,+CAAsD;AACtD,wCAAkD;AAErC,QAAA,UAAU,GAAG,CACxB,OAAoD,EACpD,KAAsB,EACL,EAAE,CAEnB,OAAO,CAAC,MAAM,CAAC,gCAAoB,CAAC;KACjC,SAAS,CAAC,MAAM,CAAC,EAAE;IAElB,MAAM,CAAC,IAAI,uBAAU,CAAC,QAAQ,CAAC,EAAE;QAE/B,MAAM,EACJ,MAAM,EACN,UAAU,GACX,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,iBAAiB,CAAA;QAEtC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,KAAK,OAAO,IAAI,MAAM,CAAC,CAAC,CAAC;YAEzC,QAAQ,CAAC,IAAI,CAAC,eAAK,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,CAAA;QAEzC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YAElB,QAAQ,CAAC,IAAI,CAAC,kBAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAA;QAEzC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,QAAQ,CAAC,IAAI,CAAC,cAAI,EAAE,CAAC,CAAA;QACvB,CAAC;QAED,QAAQ,CAAC,QAAQ,EAAE,CAAA;IACrB,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA","sourcesContent":["import { ActionsObservable } from 'redux-observable'\nimport { Observable } from 'rxjs/Observable'\nimport { LEARNING_MEME_LISTEN } from '../../constants'\nimport { check, next, setInput } from '../actions'\n\nexport const listenEpic = (\n  action$: ActionsObservable<LearningMemeListenAction>,\n  store: ObservableStore,\n): Observable<any> =>\n\n  action$.ofType(LEARNING_MEME_LISTEN)\n    .switchMap(action => {\n\n      return new Observable(observer => {\n\n        const {\n          listen,\n          inputState,\n        } = store.getState().learningMemeStore\n\n        if (action.payload === 'ENTER' && listen) {\n\n          observer.next(check(inputState.trim()))\n\n        } else if (listen) {\n\n          observer.next(setInput(action.payload))\n\n        } else {\n          observer.next(next())\n        }\n\n        observer.complete()\n      })\n    })\n"]}]}