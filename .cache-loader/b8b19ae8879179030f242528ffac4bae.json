{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/choose_word/_helpers/getFillers.ts","dependencies":[{"path":"/home/just/repos/front/src/choose_word/_helpers/getFillers.ts","mtime":1519473422445},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rambdax_1 = require(\"rambdax\");\n// how many words, besides the correct one, to be used\nconst FALSE_WORDS = 2;\n// How many short words to be ignored\nconst LOW_LIMIT = 3;\n/**\n * It returns two filler words for a given word.\n * If the fillers collection cannot give at least\n * two words, the function will return `false`.\n */\nfunction getFillers(input) {\n    const len = input.word.length;\n    if (input.fillers[len] === undefined ||\n        input.fillers[len].length < LOW_LIMIT) {\n        return [input.word];\n    }\n    const filtered = rambdax_1.filter((x) => x !== input.word, input.fillers[len]);\n    const twoWords = rambdax_1.take(FALSE_WORDS, rambdax_1.shuffle(filtered));\n    return rambdax_1.shuffle(rambdax_1.append(input.word, twoWords));\n}\nexports.getFillers = getFillers;\n",{"version":3,"file":"/home/just/repos/front/src/choose_word/_helpers/getFillers.ts","sourceRoot":"","sources":["/home/just/repos/front/src/choose_word/_helpers/getFillers.ts"],"names":[],"mappings":";;AAAA,qCAKgB;AAEhB,sDAAsD;AACtD,MAAM,WAAW,GAAG,CAAC,CAAA;AAErB,qCAAqC;AACrC,MAAM,SAAS,GAAG,CAAC,CAAA;AAEnB;;;;GAIG;AACH,oBAA2B,KAG1B;IACC,MAAM,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAA;IAE7B,EAAE,CAAC,CACD,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,SAAS;QAChC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,SAC9B,CAAC,CAAC,CAAC;QAED,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;IACrB,CAAC;IAED,MAAM,QAAQ,GAAG,gBAAM,CACrB,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,IAAI,EAC/B,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CACnB,CAAA;IAED,MAAM,QAAQ,GAAG,cAAI,CAAC,WAAW,EAAE,iBAAO,CAAC,QAAQ,CAAC,CAAC,CAAA;IAErD,MAAM,CAAC,iBAAO,CAAC,gBAAM,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAA;AAC9C,CAAC;AAtBD,gCAsBC","sourcesContent":["import {\n  append,\n  filter,\n  shuffle,\n  take,\n} from 'rambdax'\n\n// how many words, besides the correct one, to be used\nconst FALSE_WORDS = 2\n\n// How many short words to be ignored\nconst LOW_LIMIT = 3\n\n/**\n * It returns two filler words for a given word.\n * If the fillers collection cannot give at least\n * two words, the function will return `false`.\n */\nexport function getFillers(input: {\n  word: string,\n  fillers: Fillers,\n}): string[] {\n  const len = input.word.length\n\n  if (\n    input.fillers[len] === undefined ||\n    input.fillers[len].length < LOW_LIMIT\n  ) {\n\n    return [input.word]\n  }\n\n  const filtered = filter(\n    (x: string) => x !== input.word,\n    input.fillers[len],\n  )\n\n  const twoWords = take(FALSE_WORDS, shuffle(filtered))\n\n  return shuffle(append(input.word, twoWords))\n}\n"]}]}