{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/choose_word/epics/keypressEpic.ts","dependencies":[{"path":"/home/just/repos/front/src/choose_word/epics/keypressEpic.ts","mtime":1519478670273},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rambdax_1 = require(\"rambdax\");\nconst Observable_1 = require(\"rxjs/Observable\");\nconst constants_1 = require(\"../../constants\");\nconst actions_1 = require(\"../actions\");\nconst actions_2 = require(\"../actions\");\n/**\n * It listens to arrow keypress, only when `listen` prop is `true`.\n * Followed arrow keys are `up, down, right`\n *\n * @param {ActionsObservable<ChooseWordSetNextAction>} action$\n * @param {any} store\n * @returns {Observable<any>} It emits `check` action on success\n */\nexports.keypressEpic = (action$, store) => {\n    const keydownEvent = Observable_1.Observable.fromEvent(document, 'keydown');\n    const listenEvent = action$.ofType(constants_1.CHOOSE_WORD_SET_NEXT);\n    const willObserve = keydownEvent.withLatestFrom(listenEvent);\n    return willObserve.concatMap(([keydown, action]) => {\n        return new Observable_1.Observable(observer => {\n            const listen = store.getState().chooseWordStore.listen;\n            const keycode = keydown.code;\n            if (!listen) {\n                /**\n                 * When listen mode is off_\n                 * keypress action triggers next instance request\n                 */\n                observer.next(actions_2.next());\n            }\n            const condition = keycode.startsWith('Arrow') &&\n                listen;\n            const event = condition ?\n                rambdax_1.replace('Arrow', '', keycode).toUpperCase() :\n                false;\n            if (event !== false) {\n                observer.next(actions_1.check(event));\n            }\n            observer.complete();\n        });\n    });\n};\n",{"version":3,"file":"/home/just/repos/front/src/choose_word/epics/keypressEpic.ts","sourceRoot":"","sources":["/home/just/repos/front/src/choose_word/epics/keypressEpic.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AAEjC,gDAA4C;AAC5C,+CAAsD;AACtD,wCAAkC;AAClC,wCAAiC;AAEjC;;;;;;;GAOG;AACU,QAAA,YAAY,GAAG,CAC1B,OAAmD,EACnD,KAAsB,EACL,EAAE;IACnB,MAAM,YAAY,GAAG,uBAAU,CAAC,SAAS,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAA;IAC9D,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,gCAAoB,CAAC,CAAA;IAExD,MAAM,WAAW,GAAG,YAAY,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;IAE5D,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE,EAAE;QAEjD,MAAM,CAAC,IAAI,uBAAU,CAAC,QAAQ,CAAC,EAAE;YAC/B,MAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,eAAe,CAAC,MAAM,CAAA;YACtD,MAAM,OAAO,GAAI,OAAe,CAAC,IAAI,CAAA;YAErC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ;;;mBAGG;gBACH,QAAQ,CAAC,IAAI,CAAC,cAAI,EAAE,CAAC,CAAA;YACvB,CAAC;YAED,MAAM,SAAS,GAAG,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC;gBAC3C,MAAM,CAAA;YAER,MAAM,KAAK,GAAG,SAAS,CAAC,CAAC;gBACvB,iBAAO,CAAC,OAAO,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;gBAC7C,KAAK,CAAA;YAEP,EAAE,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC;gBAEpB,QAAQ,CAAC,IAAI,CAAC,eAAK,CAAC,KAAK,CAAC,CAAC,CAAA;YAC7B,CAAC;YAED,QAAQ,CAAC,QAAQ,EAAE,CAAA;QACrB,CAAC,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA","sourcesContent":["import { replace } from 'rambdax'\nimport { ActionsObservable } from 'redux-observable'\nimport { Observable } from 'rxjs/Observable'\nimport { CHOOSE_WORD_SET_NEXT } from '../../constants'\nimport { check } from '../actions'\nimport { next } from '../actions'\n\n/**\n * It listens to arrow keypress, only when `listen` prop is `true`.\n * Followed arrow keys are `up, down, right`\n *\n * @param {ActionsObservable<ChooseWordSetNextAction>} action$\n * @param {any} store\n * @returns {Observable<any>} It emits `check` action on success\n */\nexport const keypressEpic = (\n  action$: ActionsObservable<ChooseWordSetNextAction>,\n  store: ObservableStore,\n): Observable<any> => {\n  const keydownEvent = Observable.fromEvent(document, 'keydown')\n  const listenEvent = action$.ofType(CHOOSE_WORD_SET_NEXT)\n\n  const willObserve = keydownEvent.withLatestFrom(listenEvent)\n\n  return willObserve.concatMap(([keydown, action]) => {\n\n    return new Observable(observer => {\n      const listen = store.getState().chooseWordStore.listen\n      const keycode = (keydown as any).code\n\n      if (!listen) {\n        /**\n         * When listen mode is off_\n         * keypress action triggers next instance request\n         */\n        observer.next(next())\n      }\n\n      const condition = keycode.startsWith('Arrow') &&\n        listen\n\n      const event = condition ?\n        replace('Arrow', '', keycode).toUpperCase() :\n        false\n\n      if (event !== false) {\n\n        observer.next(check(event))\n      }\n\n      observer.complete()\n    })\n  })\n}\n"]}]}