{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/choose_word/_helpers/generateFillerWords.ts","dependencies":[{"path":"/home/just/repos/front/src/choose_word/_helpers/generateFillerWords.ts","mtime":1519471617597},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rambdax_1 = require(\"rambdax\");\nconst string_fn_1 = require(\"string-fn\");\n/**\n * Limits of allowed word length\n */\nconst LOW_LIMIT = 2;\nconst HIGH_LIMIT = 20;\n/**\n * It uses limits to define valid length of word will be included.\n * If a word is outside the limit, then only one choice will_\n * be presented to the user.\n *\n */\nfunction produceFn() {\n    const willReturn = {};\n    rambdax_1.range(LOW_LIMIT, HIGH_LIMIT).map(index => {\n        willReturn[index] = rambdax_1.filter((x) => x.length === index);\n    });\n    return willReturn;\n}\n/**\n * It creates a list of words from all words in the database.\n * Each member represents all the words of specific word length.\n * Property `3` will hold all words with three characters.\n * Dash(-) is removed from `filtered` because of Bulgarian\n *\n */\nfunction generateFillerWords(input) {\n    const plucked = rambdax_1.pluck('fromPart', input);\n    const mapped = rambdax_1.map(string_fn_1.wordsX, plucked);\n    const afterUniq = rambdax_1.uniq(rambdax_1.flatten(mapped));\n    const filtered = rambdax_1.filter((x) => !x.includes(',') || !x.includes('.'), afterUniq);\n    const produced = rambdax_1.produce(produceFn(), filtered);\n    return produced;\n}\nexports.generateFillerWords = generateFillerWords;\n",{"version":3,"file":"/home/just/repos/front/src/choose_word/_helpers/generateFillerWords.ts","sourceRoot":"","sources":["/home/just/repos/front/src/choose_word/_helpers/generateFillerWords.ts"],"names":[],"mappings":";;AAAA,qCAQgB;AAEhB,yCAAkC;AAElC;;GAEG;AACH,MAAM,SAAS,GAAG,CAAC,CAAA;AACnB,MAAM,UAAU,GAAG,EAAE,CAAA;AAMrB;;;;;GAKG;AACH;IACE,MAAM,UAAU,GAAG,EAAE,CAAA;IACrB,eAAK,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QACvC,UAAU,CAAC,KAAK,CAAC,GAAG,gBAAM,CAAC,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC,CAAA;IAC/D,CAAC,CAAC,CAAA;IAEF,MAAM,CAAC,UAAU,CAAA;AACnB,CAAC;AAED;;;;;;GAMG;AACH,6BAAoC,KAAoB;IACtD,MAAM,OAAO,GAAG,eAAK,CAAS,UAAU,EAAE,KAAK,CAAC,CAAA;IAChD,MAAM,MAAM,GAAG,aAAG,CAAC,kBAAM,EAAE,OAAO,CAAC,CAAA;IACnC,MAAM,SAAS,GAAG,cAAI,CAAC,iBAAO,CAAS,MAAM,CAAC,CAAC,CAAA;IAC/C,MAAM,QAAQ,GAAG,gBAAM,CACrB,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EACnD,SAAS,CACV,CAAA;IACD,MAAM,QAAQ,GAAG,iBAAO,CAAkB,SAAS,EAAE,EAAE,QAAQ,CAAC,CAAA;IAEhE,MAAM,CAAC,QAAQ,CAAA;AACjB,CAAC;AAXD,kDAWC","sourcesContent":["import {\n  filter,\n  flatten,\n  map,\n  pluck,\n  produce,\n  range,\n  uniq,\n} from 'rambdax'\n\nimport { wordsX } from 'string-fn'\n\n/**\n * Limits of allowed word length\n */\nconst LOW_LIMIT = 2\nconst HIGH_LIMIT = 20\n\ninterface ProduceOut {\n  [key: number]: string[]\n}\n\n/**\n * It uses limits to define valid length of word will be included.\n * If a word is outside the limit, then only one choice will_\n * be presented to the user.\n *\n */\nfunction produceFn() {\n  const willReturn = {}\n  range(LOW_LIMIT, HIGH_LIMIT).map(index => {\n    willReturn[index] = filter((x: string) => x.length === index)\n  })\n\n  return willReturn\n}\n\n/**\n * It creates a list of words from all words in the database.\n * Each member represents all the words of specific word length.\n * Property `3` will hold all words with three characters.\n * Dash(-) is removed from `filtered` because of Bulgarian\n *\n */\nexport function generateFillerWords(input: DataPattern[]): ProduceOut {\n  const plucked = pluck<string>('fromPart', input)\n  const mapped = map(wordsX, plucked)\n  const afterUniq = uniq(flatten<string>(mapped))\n  const filtered = filter(\n    (x: string) => !x.includes(',') || !x.includes('.'),\n    afterUniq,\n  )\n  const produced = produce<any, ProduceOut>(produceFn(), filtered)\n\n  return produced\n}\n"]}]}