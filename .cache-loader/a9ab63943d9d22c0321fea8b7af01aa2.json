{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/write_sentence/epics/initEpic.ts","dependencies":[{"path":"/home/just/repos/front/src/write_sentence/epics/initEpic.ts","mtime":1519422220162},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"../../constants\");\nconst rambdax_1 = require(\"rambdax\");\nconst Observable_1 = require(\"rxjs/Observable\");\nconst getDB_1 = require(\"../../_modules/getDB\");\nconst common_1 = require(\"../../common\");\n/**\n * Epic called from `componentDidMount`\n * Performs database filtering(if neccessary)_\n * before emitting `ready` and `next` actions\n */\nexports.initEpic = (action$, store, { getRequest }) => {\n    const init$ = action$.ofType(constants_1.WRITE_SENTENCE_INIT);\n    const db$ = action$.ofType(constants_1.INIT_READY);\n    return Observable_1.Observable.combineLatest(init$, db$).switchMap(action => {\n        return new Observable_1.Observable(observer => {\n            observer.next(common_1.sharedInit(constants_1.WRITE_SENTENCE));\n            const { randomFlag, fromLanguage, toLanguage } = common_1.getCommons(store);\n            const { db } = store.getState().store;\n            /**\n             * Filter out those DBInstance-s which_\n             * cannot be used by this application\n             */\n            const dbValue = getDB_1.getDB({ db, fromLanguage, toLanguage });\n            const payload = randomFlag ?\n                rambdax_1.shuffle(dbValue) :\n                dbValue;\n            observer.next({ type: constants_1.WRITE_SENTENCE_INIT_READY, payload });\n            rambdax_1.delay(constants_1.SHORT_DELAY).then(() => {\n                observer.next({ type: constants_1.WRITE_SENTENCE_NEXT });\n                observer.complete();\n            });\n        });\n    });\n};\n",{"version":3,"file":"/home/just/repos/front/src/write_sentence/epics/initEpic.ts","sourceRoot":"","sources":["/home/just/repos/front/src/write_sentence/epics/initEpic.ts"],"names":[],"mappings":";;AAAA,+CAOwB;AAExB,qCAAwC;AAExC,gDAA4C;AAC5C,gDAA4C;AAC5C,yCAAqD;AAErD;;;;GAIG;AACU,QAAA,QAAQ,GAAG,CACtB,OAAmD,EACnD,KAAsB,EACtB,EAAE,UAAU,EAAE,EACG,EAAE;IAEnB,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,+BAAmB,CAAC,CAAA;IACjD,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,sBAAU,CAAC,CAAA;IAEtC,MAAM,CAAC,uBAAU,CAAC,aAAa,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE;QAE7D,MAAM,CAAC,IAAI,uBAAU,CAAC,QAAQ,CAAC,EAAE;YAC/B,QAAQ,CAAC,IAAI,CAAC,mBAAU,CAAC,0BAAc,CAAC,CAAC,CAAA;YAEzC,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,GAAG,mBAAU,CAAC,KAAK,CAAC,CAAA;YAElE,MAAM,EAAE,EAAE,EAAE,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAA;YAErC;;;eAGG;YACH,MAAM,OAAO,GAAG,aAAK,CAAC,EAAE,EAAE,EAAE,YAAY,EAAE,UAAU,EAAE,CAAC,CAAA;YAEvD,MAAM,OAAO,GAAG,UAAU,CAAC,CAAC;gBAC1B,iBAAO,CAAC,OAAO,CAAC,CAAC,CAAC;gBAClB,OAAO,CAAA;YAET,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,qCAAyB,EAAE,OAAO,EAAE,CAAC,CAAA;YAE3D,eAAK,CAAC,uBAAW,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gBAC3B,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,+BAAmB,EAAE,CAAC,CAAA;gBAC5C,QAAQ,CAAC,QAAQ,EAAE,CAAA;YACrB,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA","sourcesContent":["import {\n  INIT_READY,\n  SHORT_DELAY,\n  WRITE_SENTENCE,\n  WRITE_SENTENCE_INIT,\n  WRITE_SENTENCE_INIT_READY,\n  WRITE_SENTENCE_NEXT,\n} from '../../constants'\n\nimport { delay, shuffle } from 'rambdax'\nimport { ActionsObservable } from 'redux-observable'\nimport { Observable } from 'rxjs/Observable'\nimport { getDB } from '../../_modules/getDB'\nimport { getCommons, sharedInit } from '../../common'\n\n/**\n * Epic called from `componentDidMount`\n * Performs database filtering(if neccessary)_\n * before emitting `ready` and `next` actions\n */\nexport const initEpic = (\n  action$: ActionsObservable<WriteSentenceInitAction>,\n  store: ObservableStore,\n  { getRequest },\n): Observable<any> => {\n\n  const init$ = action$.ofType(WRITE_SENTENCE_INIT)\n  const db$ = action$.ofType(INIT_READY)\n\n  return Observable.combineLatest(init$, db$).switchMap(action => {\n\n    return new Observable(observer => {\n      observer.next(sharedInit(WRITE_SENTENCE))\n\n      const { randomFlag, fromLanguage, toLanguage } = getCommons(store)\n\n      const { db } = store.getState().store\n\n      /**\n       * Filter out those DBInstance-s which_\n       * cannot be used by this application\n       */\n      const dbValue = getDB({ db, fromLanguage, toLanguage })\n\n      const payload = randomFlag ?\n        shuffle(dbValue) :\n        dbValue\n\n      observer.next({ type: WRITE_SENTENCE_INIT_READY, payload })\n\n      delay(SHORT_DELAY).then(() => {\n        observer.next({ type: WRITE_SENTENCE_NEXT })\n        observer.complete()\n      })\n    })\n  })\n}\n"]}]}