{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/write_sentence/component.tsx","dependencies":[{"path":"/home/just/repos/front/src/write_sentence/component.tsx","mtime":1520605600216},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rambdax_1 = require(\"rambdax\");\nconst React = require(\"react\");\nconst react_redux_1 = require(\"react-redux\");\nconst actions_1 = require(\"./actions\");\nconst answer_1 = require(\"./styled/answer\");\nconst question_1 = require(\"./styled/question\");\nconst translation_1 = require(\"./styled/translation\");\nconst grid_1 = require(\"./styled/grid\");\nconst image_1 = require(\"./styled/image\");\nconst input_1 = require(\"./styled/input\");\n/**\n * Defines when one sentence is too long\n * If so, then a smaller font-size is applied\n */\nconst IS_LONG_LIMIT = 57;\nexports.isLastCharSpace = (x) => {\n    return rambdax_1.last(x) === ' ';\n};\n/**\n * Shows the word if it is either pending or current\n * If the word is already passed, then hide it\n */\nfunction AnswerList(props) {\n    const { question, index } = props;\n    return React.createElement(React.Fragment, null, question.map((questionInstance, i) => {\n        const AnswerSpan = i < index ?\n            answer_1.AnswerVisible :\n            answer_1.AnswerHidden;\n        return (React.createElement(AnswerSpan, { key: i }, question[i].hidden));\n    }));\n}\n/**\n * Shows the correct words according to the local index counter\n */\nfunction QuestionList(props) {\n    const { question, index } = props;\n    return (React.createElement(React.Fragment, null, question.map((questionInstance, i) => {\n        const QuestionSpan = i === index ?\n            question_1.QuestionActive :\n            i > index ?\n                question_1.QuestionVisible :\n                question_1.QuestionHidden;\n        return React.createElement(QuestionSpan, { key: i }, question[i].visible);\n    })));\n}\n/**\n * Wraps all normal and small text components\n * If the sentence is too long, we need to display_\n * smaller version of the component.\n * Otherwise we show the standard version.\n */\nfunction getX(isLong) {\n    const whenLong = {\n        Answer: answer_1.AnswerSmall,\n        Question: question_1.QuestionSmall,\n        Translation: translation_1.TranslationSmall,\n    };\n    const whenNormal = {\n        Answer: answer_1.Answer,\n        Question: question_1.Question,\n        Translation: translation_1.Translation,\n    };\n    return isLong ? whenLong : whenNormal;\n}\nclass WriteSentence extends React.Component {\n    constructor(props) {\n        super(props);\n        this.onInputKeyPress = this.onInputKeyPress.bind(this);\n        this.onInputChange = this.onInputChange.bind(this);\n    }\n    componentDidMount() {\n        this.props.dispatch(actions_1.init());\n    }\n    componentWillUnmount() {\n        this.props.dispatch(actions_1.unmount());\n    }\n    onInputKeyPress(event) {\n        if (event.key === ' ') {\n            this.props.dispatch(actions_1.listen('SPACE'));\n        }\n    }\n    onInputChange(event) {\n        if (!exports.isLastCharSpace(event.target.value)) {\n            this.props.dispatch(actions_1.listen(event.target.value));\n        }\n    }\n    render() {\n        const ready = this.props.writeSentenceStore.ready;\n        const len = ready ?\n            this.props.writeSentenceStore.currentInstance.fromPart.length :\n            0;\n        const X = getX(len > IS_LONG_LIMIT);\n        return (React.createElement(\"div\", null, ready && React.createElement(grid_1.Container, null,\n            React.createElement(input_1.InputContainer, null,\n                React.createElement(input_1.Input, null,\n                    React.createElement(\"input\", { type: 'text', autoFocus: this.props.writeSentenceStore.ready, value: this.props.writeSentenceStore.inputState, onChange: this.onInputChange, onKeyPress: this.onInputKeyPress }))),\n            React.createElement(question_1.QuestionContainer, null,\n                React.createElement(X.Question, null,\n                    React.createElement(QuestionList, Object.assign({}, this.props.writeSentenceStore)))),\n            React.createElement(answer_1.AnswerContainer, null,\n                React.createElement(X.Answer, null,\n                    React.createElement(AnswerList, Object.assign({}, this.props.writeSentenceStore)))),\n            React.createElement(image_1.ImageContainer, null,\n                React.createElement(image_1.Image, { src: this.props.writeSentenceStore.currentInstance.imageSrc })),\n            React.createElement(translation_1.TranslationContainer, null,\n                React.createElement(X.Translation, null, this.props.writeSentenceStore.currentInstance.toPart)))));\n    }\n}\nexports.WriteSentence = WriteSentence;\nconst connectComponent = ({ writeSentenceStore }) => ({ writeSentenceStore });\nexports.WriteSentenceWrapped = react_redux_1.connect(connectComponent)(WriteSentence);\n",{"version":3,"file":"/home/just/repos/front/src/write_sentence/component.tsx","sourceRoot":"","sources":["/home/just/repos/front/src/write_sentence/component.tsx"],"names":[],"mappings":"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","sourcesContent":["import { last } from 'rambdax'\nimport * as React from 'react'\nimport { connect } from 'react-redux'\nimport { init, listen, unmount } from './actions'\n\nimport {\n  Answer,\n  AnswerContainer,\n  AnswerHidden,\n  AnswerSmall,\n  AnswerVisible,\n} from './styled/answer'\nimport {\n  Question,\n  QuestionActive,\n  QuestionContainer,\n  QuestionHidden,\n  QuestionSmall,\n  QuestionVisible,\n} from './styled/question'\nimport {\n  Translation,\n  TranslationContainer,\n  TranslationSmall,\n} from './styled/translation'\n\nimport { Container } from './styled/grid'\nimport { Image, ImageContainer } from './styled/image'\nimport { Input, InputContainer } from './styled/input'\n\n/**\n * Defines when one sentence is too long\n * If so, then a smaller font-size is applied\n */\nconst IS_LONG_LIMIT = 57\n\nexport const isLastCharSpace = (x: string): boolean => {\n\n  return last(x) === ' '\n}\n\n/**\n * Shows the word if it is either pending or current\n * If the word is already passed, then hide it\n */\nfunction AnswerList(props: any) {\n  const { question, index } = props\n\n  return <React.Fragment>{question.map((questionInstance, i) => {\n\n    const AnswerSpan = i < index ?\n      AnswerVisible :\n      AnswerHidden\n\n    return (\n      <AnswerSpan key={i}>\n        {question[i].hidden}\n      </AnswerSpan>\n    )\n  })\n  }</React.Fragment>\n}\n\n/**\n * Shows the correct words according to the local index counter\n */\nfunction QuestionList(props: any) {\n  const { question, index } = props\n\n  return (\n    <React.Fragment>{question.map((questionInstance, i) => {\n\n      const QuestionSpan = i === index ?\n        QuestionActive :\n        i > index ?\n          QuestionVisible :\n          QuestionHidden\n\n      return <QuestionSpan key={i}>\n        {question[i].visible}\n      </QuestionSpan>\n    })\n    }</React.Fragment>\n  )\n}\n\n/**\n * Wraps all normal and small text components\n * If the sentence is too long, we need to display_\n * smaller version of the component.\n * Otherwise we show the standard version.\n */\nfunction getX(isLong: boolean) {\n  const whenLong = {\n    Answer: AnswerSmall,\n    Question: QuestionSmall,\n    Translation: TranslationSmall,\n  }\n\n  const whenNormal = {\n    Answer,\n    Question,\n    Translation,\n  }\n\n  return isLong ? whenLong : whenNormal\n}\n\nexport class WriteSentence extends React.Component<WriteSentenceProps, {}> {\n  constructor(props: WriteSentenceProps) {\n    super(props)\n    this.onInputKeyPress = this.onInputKeyPress.bind(this)\n    this.onInputChange = this.onInputChange.bind(this)\n  }\n  public componentDidMount() {\n    this.props.dispatch(init())\n  }\n  public componentWillUnmount() {\n    this.props.dispatch(unmount())\n  }\n  public onInputKeyPress(event: any) {\n    if (event.key === ' ') {\n\n      this.props.dispatch(listen('SPACE'))\n    }\n  }\n  public onInputChange(event: any) {\n    if (!isLastCharSpace(event.target.value)) {\n\n      this.props.dispatch(listen(event.target.value))\n    }\n  }\n  public render() {\n    const ready = this.props.writeSentenceStore.ready\n    const len = ready ?\n      this.props.writeSentenceStore.currentInstance.fromPart.length :\n      0\n\n    const X = getX(len > IS_LONG_LIMIT)\n\n    return (\n\n      <div>\n        {ready && <Container>\n\n          <InputContainer>\n            <Input>\n              <input\n                type='text'\n                autoFocus={this.props.writeSentenceStore.ready}\n                value={this.props.writeSentenceStore.inputState}\n                onChange={this.onInputChange}\n                onKeyPress={this.onInputKeyPress}\n              />\n            </Input>\n          </InputContainer>\n\n          <QuestionContainer>\n            <X.Question>\n              <QuestionList {...this.props.writeSentenceStore} />\n            </X.Question>\n          </QuestionContainer>\n\n          <AnswerContainer>\n            <X.Answer>\n              <AnswerList {...this.props.writeSentenceStore} />\n            </X.Answer>\n          </AnswerContainer>\n\n          <ImageContainer>\n            <Image\n              src={this.props.writeSentenceStore.currentInstance.imageSrc}\n            />\n          </ImageContainer>\n\n          <TranslationContainer>\n            <X.Translation>\n              {this.props.writeSentenceStore.currentInstance.toPart}\n            </X.Translation>\n          </TranslationContainer>\n\n        </Container>}\n      </div>\n    )\n  }\n}\n\nconst connectComponent = ({ writeSentenceStore }) => ({ writeSentenceStore })\n\nexport const WriteSentenceWrapped = connect(connectComponent)(WriteSentence)\n"]}]}