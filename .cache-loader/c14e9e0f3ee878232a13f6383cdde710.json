{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/choose_word/epics/nextEpic.ts","dependencies":[{"path":"/home/just/repos/front/src/choose_word/epics/nextEpic.ts","mtime":1519470860609},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Observable_1 = require(\"rxjs/Observable\");\nconst string_fn_1 = require(\"string-fn\");\nconst common_1 = require(\"../../common\");\nconst constants_1 = require(\"../../constants\");\nconst getFillers_1 = require(\"../_helpers/getFillers\");\n/**\n * It represents generation of the next current instance.\n *\n *\n * @param {ActionsObservable<ChooseWordNextAction>} action$\n * @param {ObservableStore} store\n * @returns {Observable<any>}\n */\nexports.nextEpic = (action$, store) => action$.ofType(constants_1.CHOOSE_WORD_NEXT)\n    .switchMap(action => {\n    return new Observable_1.Observable(observer => {\n        const { textToSpeechFlag } = common_1.getCommons(store);\n        const { currentIndex: currentIndexRaw, db, fillerWords, ready, } = store.getState().chooseWordStore;\n        const currentIndex = common_1.getNextIndex({\n            index: currentIndexRaw,\n            length: db.length,\n        });\n        const currentInstance = db[currentIndex];\n        const correctAnswer = string_fn_1.wordsX(currentInstance.fromPart);\n        const question = correctAnswer.map(singleWord => getFillers_1.getFillers({\n            fillers: fillerWords,\n            word: singleWord,\n        }));\n        const payload = {\n            correctAnswer,\n            currentIndex,\n            currentInstance,\n            question,\n        };\n        observer.next({ type: constants_1.CHOOSE_WORD_SET_NEXT, payload });\n        if (!ready) {\n            observer.next({ type: constants_1.CHOOSE_WORD_READY });\n        }\n        if (textToSpeechFlag) {\n            observer.next({ type: constants_1.SHARED_SPEAK, payload: 'toPart' });\n        }\n        observer.complete();\n    });\n});\n",{"version":3,"file":"/home/just/repos/front/src/choose_word/epics/nextEpic.ts","sourceRoot":"","sources":["/home/just/repos/front/src/choose_word/epics/nextEpic.ts"],"names":[],"mappings":";;AACA,gDAA4C;AAC5C,yCAAkC;AAClC,yCAAuD;AACvD,+CAKwB;AACxB,uDAAmD;AAEnD;;;;;;;GAOG;AACU,QAAA,QAAQ,GAAG,CACtB,OAAgD,EAChD,KAAsB,EACL,EAAE,CAEnB,OAAO,CAAC,MAAM,CAAC,4BAAgB,CAAC;KAC7B,SAAS,CAAC,MAAM,CAAC,EAAE;IAClB,MAAM,CAAC,IAAI,uBAAU,CAAC,QAAQ,CAAC,EAAE;QAE/B,MAAM,EAAE,gBAAgB,EAAE,GAAG,mBAAU,CAAC,KAAK,CAAC,CAAA;QAE9C,MAAM,EACJ,YAAY,EAAE,eAAe,EAC7B,EAAE,EACF,WAAW,EACX,KAAK,GACN,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,eAAe,CAAA;QAEpC,MAAM,YAAY,GAAG,qBAAY,CAAC;YAChC,KAAK,EAAE,eAAe;YACtB,MAAM,EAAE,EAAE,CAAC,MAAM;SAClB,CAAC,CAAA;QAEF,MAAM,eAAe,GAAG,EAAE,CAAC,YAAY,CAAC,CAAA;QAExC,MAAM,aAAa,GAAG,kBAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAA;QAEtD,MAAM,QAAQ,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAC9C,uBAAU,CAAC;YACT,OAAO,EAAE,WAAW;YACpB,IAAI,EAAE,UAAU;SACjB,CAAC,CACH,CAAA;QAED,MAAM,OAAO,GAAG;YACd,aAAa;YACb,YAAY;YACZ,eAAe;YACf,QAAQ;SACT,CAAA;QAED,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,gCAAoB,EAAE,OAAO,EAAE,CAAC,CAAA;QAEtD,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,6BAAiB,EAAE,CAAC,CAAA;QAC5C,CAAC;QAED,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;YACrB,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,wBAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAA;QAC1D,CAAC;QAED,QAAQ,CAAC,QAAQ,EAAE,CAAA;IACrB,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA","sourcesContent":["import { ActionsObservable } from 'redux-observable'\nimport { Observable } from 'rxjs/Observable'\nimport { wordsX } from 'string-fn'\nimport { getCommons, getNextIndex } from '../../common'\nimport {\n  CHOOSE_WORD_NEXT,\n  CHOOSE_WORD_READY,\n  CHOOSE_WORD_SET_NEXT,\n  SHARED_SPEAK,\n} from '../../constants'\nimport { getFillers } from '../_helpers/getFillers'\n\n/**\n * It represents generation of the next current instance.\n *\n *\n * @param {ActionsObservable<ChooseWordNextAction>} action$\n * @param {ObservableStore} store\n * @returns {Observable<any>}\n */\nexport const nextEpic = (\n  action$: ActionsObservable<ChooseWordNextAction>,\n  store: ObservableStore,\n): Observable<any> =>\n\n  action$.ofType(CHOOSE_WORD_NEXT)\n    .switchMap(action => {\n      return new Observable(observer => {\n\n        const { textToSpeechFlag } = getCommons(store)\n\n        const {\n          currentIndex: currentIndexRaw,\n          db,\n          fillerWords,\n          ready,\n        } = store.getState().chooseWordStore\n\n        const currentIndex = getNextIndex({\n          index: currentIndexRaw,\n          length: db.length,\n        })\n\n        const currentInstance = db[currentIndex]\n\n        const correctAnswer = wordsX(currentInstance.fromPart)\n\n        const question = correctAnswer.map(singleWord =>\n          getFillers({\n            fillers: fillerWords,\n            word: singleWord,\n          }),\n        )\n\n        const payload = {\n          correctAnswer,\n          currentIndex,\n          currentInstance,\n          question,\n        }\n\n        observer.next({ type: CHOOSE_WORD_SET_NEXT, payload })\n\n        if (!ready) {\n          observer.next({ type: CHOOSE_WORD_READY })\n        }\n\n        if (textToSpeechFlag) {\n          observer.next({ type: SHARED_SPEAK, payload: 'toPart' })\n        }\n\n        observer.complete()\n      })\n    })\n"]}]}