{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/_modules/getDB.ts","dependencies":[{"path":"/home/just/repos/front/src/_modules/getDB.ts","mtime":1519647513787},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rambdax_1 = require(\"rambdax\");\nconst string_fn_1 = require(\"string-fn\");\n/**\n * These word patterns are allowed only inside the sentence_\n * not in its beginning\n */\nfunction handleBulgarianException(fromWordBase) {\n    return fromWordBase.startsWith('по-') || fromWordBase.startsWith('най-');\n}\nexports.getDB = (input) => {\n    const { fromLanguage, toLanguage, db } = input;\n    const filterFn = xInstance => {\n        try {\n            const fromPart = xInstance[`${fromLanguage.toLowerCase()}Part`];\n            const fromWordRaw = xInstance[`${fromLanguage.toLowerCase()}Word`];\n            const hasToLanguageWord = xInstance[`${toLanguage.toLowerCase()}Word`] !== undefined;\n            const hasToLanguagePart = xInstance[`${toLanguage.toLowerCase()}Part`] !== undefined;\n            const hasToLanguage = hasToLanguagePart && hasToLanguageWord;\n            const canContinue = fromPart !== undefined &&\n                fromWordRaw !== undefined &&\n                hasToLanguage;\n            // This happens because not all instances have Bulgarian language\n            if (!canContinue) {\n                return false;\n            }\n            const fromWord = rambdax_1.head(fromWordRaw.split(','));\n            const fromWordBase = rambdax_1.last(fromWord.split(' '));\n            const words = string_fn_1.wordsX(fromPart).map(x => x.toLowerCase());\n            return words.includes(fromWordBase.toLowerCase()) ||\n                handleBulgarianException(fromWordBase);\n        }\n        catch (e) {\n            throw e;\n        }\n    };\n    const filtered = rambdax_1.filter(filterFn, db);\n    const mapped = rambdax_1.map(xInstance => {\n        const fromPart = xInstance[`${fromLanguage.toLowerCase()}Part`];\n        const toPart = xInstance[`${toLanguage.toLowerCase()}Part`];\n        const fromWordRaw = xInstance[`${fromLanguage.toLowerCase()}Word`];\n        const fromWord = rambdax_1.head(fromWordRaw.split(','));\n        const toWord = xInstance[`${toLanguage.toLowerCase()}Word`];\n        const imageSrc = xInstance.imageSrc;\n        return {\n            fromPart,\n            fromWord,\n            imageSrc,\n            toPart,\n            toWord,\n        };\n    }, filtered);\n    return mapped;\n};\n",{"version":3,"file":"/home/just/repos/front/src/_modules/getDB.ts","sourceRoot":"","sources":["/home/just/repos/front/src/_modules/getDB.ts"],"names":[],"mappings":";;AAAA,qCAKgB;AAEhB,yCAAkC;AAElC;;;GAGG;AACH,kCAAkC,YAAoB;IACpD,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC,UAAU,CAAC,MAAM,CAAC,CAAA;AAC1E,CAAC;AAEY,QAAA,KAAK,GAAG,CAAC,KAAY,EAAiB,EAAE;IACnD,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,EAAE,EAAE,GAAG,KAAK,CAAA;IAE9C,MAAM,QAAQ,GAAG,SAAS,CAAC,EAAE;QAC3B,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,SAAS,CAAC,GAAG,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;YAC/D,MAAM,WAAW,GAAW,SAAS,CAAC,GAAG,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;YAE1E,MAAM,iBAAiB,GAAG,SAAS,CAAC,GAAG,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,KAAK,SAAS,CAAA;YACpF,MAAM,iBAAiB,GAAG,SAAS,CAAC,GAAG,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,KAAK,SAAS,CAAA;YAEpF,MAAM,aAAa,GAAG,iBAAiB,IAAI,iBAAiB,CAAA;YAE5D,MAAM,WAAW,GAAG,QAAQ,KAAK,SAAS;gBACxC,WAAW,KAAK,SAAS;gBACzB,aAAa,CAAA;YAEf,iEAAiE;YACjE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBAEjB,MAAM,CAAC,KAAK,CAAA;YACd,CAAC;YAED,MAAM,QAAQ,GAAW,cAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;YAErD,MAAM,YAAY,GAAW,cAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;YAEtD,MAAM,KAAK,GAAG,kBAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAA;YAExD,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;gBAC/C,wBAAwB,CAAC,YAAY,CAAC,CAAA;QAC1C,CAAC;QAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACX,MAAM,CAAC,CAAA;QACT,CAAC;IACH,CAAC,CAAA;IAED,MAAM,QAAQ,GAAG,gBAAM,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAA;IAErC,MAAM,MAAM,GAAkB,aAAG,CAAmB,SAAS,CAAC,EAAE;QAC9D,MAAM,QAAQ,GAAW,SAAS,CAAC,GAAG,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QACvE,MAAM,MAAM,GAAG,SAAS,CAAC,GAAG,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QAE3D,MAAM,WAAW,GAAG,SAAS,CAAC,GAAG,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QAClE,MAAM,QAAQ,GAAW,cAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;QAErD,MAAM,MAAM,GAAG,SAAS,CAAC,GAAG,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QAC3D,MAAM,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAA;QAEnC,MAAM,CAAC;YACL,QAAQ;YACR,QAAQ;YACR,QAAQ;YACR,MAAM;YACN,MAAM;SACP,CAAA;IACH,CAAC,EAAE,QAAQ,CAAC,CAAA;IAEZ,MAAM,CAAC,MAAM,CAAA;AACf,CAAC,CAAA","sourcesContent":["import {\n  filter,\n  head,\n  last,\n  map,\n} from 'rambdax'\n\nimport { wordsX } from 'string-fn'\n\n/**\n * These word patterns are allowed only inside the sentence_\n * not in its beginning\n */\nfunction handleBulgarianException(fromWordBase: string): boolean {\n  return fromWordBase.startsWith('по-') || fromWordBase.startsWith('най-')\n}\n\nexport const getDB = (input: GetDB): DataPattern[] => {\n  const { fromLanguage, toLanguage, db } = input\n\n  const filterFn = xInstance => {\n    try {\n      const fromPart = xInstance[`${fromLanguage.toLowerCase()}Part`]\n      const fromWordRaw: string = xInstance[`${fromLanguage.toLowerCase()}Word`]\n\n      const hasToLanguageWord = xInstance[`${toLanguage.toLowerCase()}Word`] !== undefined\n      const hasToLanguagePart = xInstance[`${toLanguage.toLowerCase()}Part`] !== undefined\n\n      const hasToLanguage = hasToLanguagePart && hasToLanguageWord\n\n      const canContinue = fromPart !== undefined &&\n        fromWordRaw !== undefined &&\n        hasToLanguage\n\n      // This happens because not all instances have Bulgarian language\n      if (!canContinue) {\n\n        return false\n      }\n\n      const fromWord: string = head(fromWordRaw.split(','))\n\n      const fromWordBase: string = last(fromWord.split(' '))\n\n      const words = wordsX(fromPart).map(x => x.toLowerCase())\n\n      return words.includes(fromWordBase.toLowerCase()) ||\n        handleBulgarianException(fromWordBase)\n    } catch (e) {\n      throw e\n    }\n  }\n\n  const filtered = filter(filterFn, db)\n\n  const mapped: DataPattern[] = map<any, DataPattern>(xInstance => {\n    const fromPart: string = xInstance[`${fromLanguage.toLowerCase()}Part`]\n    const toPart = xInstance[`${toLanguage.toLowerCase()}Part`]\n\n    const fromWordRaw = xInstance[`${fromLanguage.toLowerCase()}Word`]\n    const fromWord: string = head(fromWordRaw.split(','))\n\n    const toWord = xInstance[`${toLanguage.toLowerCase()}Word`]\n    const imageSrc = xInstance.imageSrc\n\n    return {\n      fromPart,\n      fromWord,\n      imageSrc,\n      toPart,\n      toWord,\n    }\n  }, filtered)\n\n  return mapped\n}\n"]}]}