{"remainingRequest":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js??ref--4-1!/home/just/repos/front/node_modules/ts-loader/index.js??ref--4-2!/home/just/repos/front/src/learning_meme/epics/nextEpic.ts","dependencies":[{"path":"/home/just/repos/front/src/learning_meme/epics/nextEpic.ts","mtime":1519156859236},{"path":"/home/just/repos/front/node_modules/cache-loader/dist/cjs.js","mtime":1520676156713},{"path":"/home/just/repos/front/node_modules/thread-loader/dist/cjs.js","mtime":1520676204585},{"path":"/home/just/repos/front/node_modules/ts-loader/index.js","mtime":1520676144729}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rambdax_1 = require(\"rambdax\");\nconst Observable_1 = require(\"rxjs/Observable\");\nconst string_fn_1 = require(\"string-fn\");\nconst common_1 = require(\"../../common\");\nconst constants_1 = require(\"../../constants\");\nconst constants_2 = require(\"../../constants\");\nconst CHAR_LIMIT = 4;\nexports.nextEpic = (action$, store) => action$.ofType(constants_2.LEARNING_MEME_NEXT)\n    .switchMap(action => {\n    return new Observable_1.Observable(observer => {\n        const { textToSpeechFlag } = common_1.getCommons(store);\n        const { currentIndex: currentIndexRaw, db, ready, } = store.getState().learningMemeStore;\n        const currentIndex = common_1.getNextIndex({\n            index: currentIndexRaw,\n            length: db.length,\n        });\n        const currentInstance = db[currentIndex];\n        // turn die Frage to d__ F___e\n        const question = string_fn_1.maskWords({\n            charLimit: CHAR_LIMIT,\n            words: currentInstance.fromWord,\n        });\n        // get visible and hidden array with words where question words are masked\n        const sentenceRaw = string_fn_1.maskSentence({\n            charLimit: CHAR_LIMIT,\n            sentence: currentInstance.fromPart,\n            words: currentInstance.fromWord.split(' '),\n        });\n        // turn visible and hidden array of words to two whole sentences\n        const sentence = rambdax_1.map((x) => x.join(' ').trim(), sentenceRaw);\n        const payload = {\n            currentIndex,\n            currentInstance,\n            question,\n            sentence,\n        };\n        // Ready to set the state\n        observer.next({ type: constants_2.LEARNING_MEME_SET_NEXT, payload });\n        // On the very first step we need to wait for\n        // setting of state and rendering to happen\n        // then we emit actions\n        // if this is not the very first step\n        // then we emit actions right away\n        const ms = ready ?\n            constants_1.NEXT_TICK :\n            constants_2.SHORT_DELAY;\n        rambdax_1.delay(ms).then(() => {\n            observer.next({ type: constants_2.LEARNING_MEME_READY });\n            if (textToSpeechFlag) {\n                observer.next({ type: constants_1.SHARED_SPEAK, payload: 'toPart' });\n            }\n            observer.complete();\n        });\n    });\n});\n",{"version":3,"file":"/home/just/repos/front/src/learning_meme/epics/nextEpic.ts","sourceRoot":"","sources":["/home/just/repos/front/src/learning_meme/epics/nextEpic.ts"],"names":[],"mappings":";;AAAA,qCAAoC;AAEpC,gDAA4C;AAC5C,yCAAuE;AACvE,yCAAuD;AACvD,+CAAyD;AACzD,+CAKwB;AAExB,MAAM,UAAU,GAAG,CAAC,CAAA;AAEP,QAAA,QAAQ,GAAG,CACtB,OAAkD,EAClD,KAAsB,EACL,EAAE,CAEnB,OAAO,CAAC,MAAM,CAAC,8BAAkB,CAAC;KAC/B,SAAS,CAAC,MAAM,CAAC,EAAE;IAClB,MAAM,CAAC,IAAI,uBAAU,CAAC,QAAQ,CAAC,EAAE;QAC/B,MAAM,EAAE,gBAAgB,EAAE,GAAG,mBAAU,CAAC,KAAK,CAAC,CAAA;QAE9C,MAAM,EACJ,YAAY,EAAE,eAAe,EAC7B,EAAE,EACF,KAAK,GACN,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,iBAAiB,CAAA;QAEtC,MAAM,YAAY,GAAG,qBAAY,CAAC;YAChC,KAAK,EAAE,eAAe;YACtB,MAAM,EAAE,EAAE,CAAC,MAAM;SAClB,CAAC,CAAA;QAEF,MAAM,eAAe,GAAG,EAAE,CAAC,YAAY,CAAC,CAAA;QAExC,8BAA8B;QAC9B,MAAM,QAAQ,GAAW,qBAAS,CAAC;YACjC,SAAS,EAAE,UAAU;YACrB,KAAK,EAAE,eAAe,CAAC,QAAQ;SAChC,CAAC,CAAA;QAEF,0EAA0E;QAC1E,MAAM,WAAW,GAAuB,wBAAY,CAAC;YACnD,SAAS,EAAE,UAAU;YACrB,QAAQ,EAAE,eAAe,CAAC,QAAQ;YAClC,KAAK,EAAE,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC;SAC3C,CAAC,CAAA;QAEF,gEAAgE;QAChE,MAAM,QAAQ,GAAG,aAAG,CAClB,CAAC,CAAW,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EACnC,WAAW,CACZ,CAAA;QAED,MAAM,OAAO,GAAG;YACd,YAAY;YACZ,eAAe;YACf,QAAQ;YACR,QAAQ;SACT,CAAA;QAED,yBAAyB;QACzB,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,kCAAsB,EAAE,OAAO,EAAE,CAAC,CAAA;QAExD,6CAA6C;QAC7C,2CAA2C;QAC3C,uBAAuB;QAEvB,qCAAqC;QACrC,kCAAkC;QAClC,MAAM,EAAE,GAAG,KAAK,CAAC,CAAC;YAChB,qBAAS,CAAC,CAAC;YACX,uBAAW,CAAA;QAEb,eAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;YAClB,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,+BAAmB,EAAE,CAAC,CAAA;YAE5C,EAAE,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBAErB,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,wBAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAA;YAE1D,CAAC;YAED,QAAQ,CAAC,QAAQ,EAAE,CAAA;QACrB,CAAC,CAAC,CAAA;IAEJ,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA","sourcesContent":["import { delay, map } from 'rambdax'\nimport { ActionsObservable } from 'redux-observable'\nimport { Observable } from 'rxjs/Observable'\nimport { maskSentence, maskWords, OutputMaskSentence } from 'string-fn'\nimport { getCommons, getNextIndex } from '../../common'\nimport { NEXT_TICK, SHARED_SPEAK } from '../../constants'\nimport {\n  LEARNING_MEME_NEXT,\n  LEARNING_MEME_READY,\n  LEARNING_MEME_SET_NEXT,\n  SHORT_DELAY,\n} from '../../constants'\n\nconst CHAR_LIMIT = 4\n\nexport const nextEpic = (\n  action$: ActionsObservable<LearningMemeNextAction>,\n  store: ObservableStore,\n): Observable<any> =>\n\n  action$.ofType(LEARNING_MEME_NEXT)\n    .switchMap(action => {\n      return new Observable(observer => {\n        const { textToSpeechFlag } = getCommons(store)\n\n        const {\n          currentIndex: currentIndexRaw,\n          db,\n          ready,\n        } = store.getState().learningMemeStore\n\n        const currentIndex = getNextIndex({\n          index: currentIndexRaw,\n          length: db.length,\n        })\n\n        const currentInstance = db[currentIndex]\n\n        // turn die Frage to d__ F___e\n        const question: string = maskWords({\n          charLimit: CHAR_LIMIT,\n          words: currentInstance.fromWord,\n        })\n\n        // get visible and hidden array with words where question words are masked\n        const sentenceRaw: OutputMaskSentence = maskSentence({\n          charLimit: CHAR_LIMIT,\n          sentence: currentInstance.fromPart,\n          words: currentInstance.fromWord.split(' '),\n        })\n\n        // turn visible and hidden array of words to two whole sentences\n        const sentence = map<any, string>(\n          (x: string[]) => x.join(' ').trim(),\n          sentenceRaw,\n        )\n\n        const payload = {\n          currentIndex,\n          currentInstance,\n          question,\n          sentence,\n        }\n\n        // Ready to set the state\n        observer.next({ type: LEARNING_MEME_SET_NEXT, payload })\n\n        // On the very first step we need to wait for\n        // setting of state and rendering to happen\n        // then we emit actions\n\n        // if this is not the very first step\n        // then we emit actions right away\n        const ms = ready ?\n          NEXT_TICK :\n          SHORT_DELAY\n\n        delay(ms).then(() => {\n          observer.next({ type: LEARNING_MEME_READY })\n\n          if (textToSpeechFlag) {\n\n            observer.next({ type: SHARED_SPEAK, payload: 'toPart' })\n\n          }\n\n          observer.complete()\n        })\n\n      })\n    })\n"]}]}